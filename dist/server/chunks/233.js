"use strict";exports.id=233,exports.ids=[233],exports.modules={59233:(e,t,r)=>{r.d(t,{XK:()=>l,jX:()=>isCustomerPaid,sA:()=>i});var a=r(29904),n=r(60755);let o="orders",coerceIsoString=(e,t)=>{if(!e)return t;if("string"==typeof e)return e;if("number"==typeof e)try{return new Date(e).toISOString()}catch{return t}if(e instanceof Date)return e.toISOString();if("function"==typeof e.toDate)try{return e.toDate().toISOString()}catch{}return t},normalizePaymentRecord=e=>{let t=coerceIsoString(e.date,new Date().toISOString()),r=coerceIsoString(e.createdAt,t)||t;return{...e,amount:Number(e.amount)||0,date:t,createdAt:r}},roundDelta=e=>.01>Math.abs(e)?0:Number(e.toFixed(2)),calculateExpenseAdjustment=(e,t)=>{if(!t||0===t.length)return 0;let r=Number(e||0),a=t.reduce((e,t)=>e+Number(t.amount||0),0);return a>=r-250||a>=r?roundDelta(r-a):0},calculateRevenueAdjustment=(e,t)=>{if(!t||0===t.length)return 0;let r=Number(e||0),a=t.reduce((e,t)=>e+Number(t.amount||0),0);return roundDelta(a-r)},isExpensePaid=e=>{let t=Number(e.originalTotal||0);if(t<=0)return!1;let r=e.partialPayments||[],a=r.reduce((e,t)=>e+t.amount,0);return a>=t-250},isCustomerPaid=e=>{let t=Number(e.total||0);if(t<=0)return!1;let r=e.customerPayments||[],a=r.reduce((e,t)=>e+t.amount,0);return a>=t-250},i=isExpensePaid,l={async ensureLedgerEntriesForPayments(e,t){let a=[...e];for(let e=0;e<a.length;e++){let n=a[e];if(!n.ledgerEntryId)try{let{ledgerService:o}=await r.e(512).then(r.bind(r,9909));console.log("Creating missing ledger entry for payment:",n);let i=await o.addEntry("debit",n.amount,n.note?`Order Payment (${t.truckNo||"Unknown Truck"}): ${n.note}`:`Order Payment: ${t.truckNo||t.id||"Unknown Order"}`,"orderExpense",n.date||new Date().toISOString(),void 0,void 0);a[e]={...n,ledgerEntryId:i},console.log("Γ\xa3\xe0 Created ledger entry:",i)}catch(e){console.error("Γ\xa5\xee Failed to create ledger entry for payment:",e)}}return a},async createOrder(e){let t=(0,n.z)();if(!t){let e="Firebase db is not initialized. Check your Firebase configuration and .env.local file.";throw console.error(e),console.error("Environment check:",{hasApiKey:!0,hasProjectId:!0,hasAppId:!0,isClient:!1}),Error(e)}try{e.paidAmountForRawMaterials,e.originalTotal;let{paidAmountForRawMaterials:r,...n}=e,i=e.partialPayments||[];i.length>0&&(i=await this.ensureLedgerEntriesForPayments(i,{truckNo:e.truckNo,supplier:e.supplier})),i=i.map(normalizePaymentRecord);let l=(e.customerPayments||[]).map(normalizePaymentRecord),d=calculateExpenseAdjustment(e.originalTotal||0,i),s=calculateRevenueAdjustment(e.total||0,l),u={...n,partialPayments:i,...i.length>0?{expenseAdjustment:d}:{},...l.length>0?{revenueAdjustment:s}:{},createdAt:new Date().toISOString(),updatedAt:new Date().toISOString()};console.log("Creating order in Firestore:",{collection:o,data:u,dbInitialized:!!t});let c=new Promise((e,t)=>{setTimeout(()=>{console.error("Γ\xa5\xee Save operation timed out after 10 seconds"),console.error("This usually means Firestore security rules are blocking the request."),t(Error('Request timeout. This usually means Firestore security rules are blocking writes. Please check your Firestore rules in Firebase Console and ensure they allow writes to the "orders" collection.'))},1e4)});console.log("Γ\xc5│ Attempting to save to Firestore...");let m=(0,a.ET)((0,a.hJ)(t,o),u),y=await Promise.race([m,c]);return console.log("Γ\xa3\xe0 Order created successfully with ID:",y.id),y.id}catch(e){if(console.error("Γ\xa5\xee Firestore error creating order:",e),console.error("Error details:",{code:e?.code,message:e?.message,stack:e?.stack}),"permission-denied"===e.code)throw Error("Permission denied. Please check your Firestore security rules in Firebase Console. Rules should allow: allow read, write: if true;");if("unavailable"===e.code)throw Error("Firestore is unavailable. Please check your internet connection.");if("failed-precondition"===e.code)throw Error("Firestore database not found. Please create the database in Firebase Console.");throw Error(`Failed to save order: ${e.message||"Unknown error"}`)}},async updateOrder(e,t){let r=(0,n.z)();if(!r)throw console.error("Firebase db is not initialized. Check your Firebase configuration."),Error("Firebase is not configured. Please set up your .env.local file with Firebase credentials. See README.md for setup instructions.");try{let n=await this.getOrderById(e);if(!n)throw Error("Order not found");let i={updatedAt:new Date().toISOString()};t.partialPayments&&Array.isArray(t.partialPayments)&&t.partialPayments.length>0&&(t.partialPayments=await this.ensureLedgerEntriesForPayments(t.partialPayments,{truckNo:t.truckNo||n.truckNo,id:e,supplier:t.supplier||n.supplier})),Object.keys(t).forEach(e=>{let r=t[e];if(void 0!==r){if("partialPayments"===e){if(Array.isArray(r)&&r.length>0){let a=r.map(normalizePaymentRecord);i[e]=a;let o=Number(t.originalTotal??n.originalTotal??0);i.expenseAdjustment=calculateExpenseAdjustment(o,a)}else r&&Array.isArray(r)&&0===r.length&&(i.expenseAdjustment=0)}else if("customerPayments"===e){if(Array.isArray(r)&&r.length>0){let a=r.map(normalizePaymentRecord);i[e]=a;let o=Number(t.total??n.total??0);i.revenueAdjustment=calculateRevenueAdjustment(o,a)}else r&&Array.isArray(r)&&0===r.length&&(i.revenueAdjustment=0)}else i[e]=r}});let l=(0,a.JU)(r,o,e);await (0,a.r7)(l,i),console.log("Γ\xa3\xe0 Order updated successfully:",e)}catch(e){if(console.error("Firestore error updating order:",e),"permission-denied"===e.code)throw Error("Permission denied. Please check your Firestore security rules.");throw Error(`Failed to update order: ${e.message||"Unknown error"}`)}},async deleteOrder(e){let t=(0,n.z)();if(!t)throw Error("Firebase is not configured. Please set up your .env.local file with Firebase credentials.");try{console.log("Deleting order from Firestore:",e),await (0,a.oe)((0,a.JU)(t,o,e)),console.log("Order deleted successfully:",e)}catch(e){if(console.error("Firestore error deleting order:",e),"permission-denied"===e.code)throw Error("Permission denied. Please check your Firestore security rules.");throw Error(`Failed to delete order: ${e.message||"Unknown error"}`)}},async getAllOrders(e){let t=(0,n.z)();if(!t)return console.warn("Firebase is not configured. Returning empty array."),[];let r=!!(e?.supplier||e?.partyName||e?.material||e?.truckOwner||e?.truckNo),i=(0,a.hJ)(t,o);r||(i=(0,a.IO)(i,(0,a.Xo)("date","desc"))),e&&(e.partyName&&(i=(0,a.IO)(i,(0,a.ar)("partyName","==",e.partyName))),e.material&&(i=(0,a.IO)(i,(0,a.ar)("material","==",e.material))),e.truckOwner&&(i=(0,a.IO)(i,(0,a.ar)("truckOwner","==",e.truckOwner))),e.truckNo&&(i=(0,a.IO)(i,(0,a.ar)("truckNo","==",e.truckNo))),e.supplier&&(i=(0,a.IO)(i,(0,a.ar)("supplier","==",e.supplier))));let l=await (0,a.PL)(i),d=[];l.forEach(e=>{let t=e.data(),r={id:e.id};for(let e in t)if(Object.prototype.hasOwnProperty.call(t,e)){let a=t[e];if(a&&"function"==typeof a.toDate){let t=a.toDate();"date"===e?r[e]=t.toISOString().split("T")[0]:r[e]=t.toISOString()}else r[e]=a}r.partialPayments&&(Array.isArray(r.partialPayments)?r.partialPayments=r.partialPayments.map(e=>normalizePaymentRecord(e)):r.partialPayments=[]),r.customerPayments&&(Array.isArray(r.customerPayments)?r.customerPayments=r.customerPayments.map(e=>normalizePaymentRecord(e)):r.customerPayments=[]),d.push(r)}),r&&d.sort((e,t)=>{let r=new Date(e.date).getTime(),a=new Date(t.date).getTime();return a-r});let s=d;return(e?.startDate||e?.endDate)&&(s=d.filter(t=>{let r=new Date(t.date);return!(e.startDate&&r<new Date(e.startDate)||e.endDate&&r>new Date(e.endDate))})),s},async getOrderById(e){let t=await this.getAllOrders();return t.find(t=>t.id===e)||null},async addPaymentToOrder(e,t,n,o){let l;let d=await this.getOrderById(e);if(!d)throw Error("Order not found");let s=Number(d.originalTotal||0),u=d.partialPayments||[],c=u.reduce((e,t)=>e+Number(t.amount||0),0),m=i(d);if(m&&!o&&console.warn(`Γ\xdc\xe1∩╕\xc5 Adding payment to already paid order. Current total: ${c}, Original: ${s}`),t<=0)throw Error("Payment amount must be greater than 0");let y=u.filter(e=>e.ledgerEntryId),p=y.length>0,g=y.reduce((e,t)=>e+Number(t.amount||0),0),f=c+t;if(f>s&&!o){let e=f-s;console.warn(`Γ\xdc\xe1∩╕\xc5 Overpayment detected: ${e} over original total. Total: ${f}, Original: ${s}${p?`, Ledger payments: ${g}`:""}`)}let h=new Date().toISOString();try{let{ledgerService:a}=await r.e(512).then(r.bind(r,9909));l=await a.addEntry("debit",t,n?`Order Payment (${d.truckNo||"Unknown Truck"}): ${n}`:`Order Payment: ${d.truckNo||e}`,"orderExpense",h,void 0,void 0),console.log("Γ\xa3\xe0 Created linked ledger entry:",l)}catch(e){console.error("Γ\xa5\xee Failed to create linked ledger entry for order payment:",e)}let w={id:Date.now().toString()+Math.random().toString(36).substr(2,9),amount:t,date:h,createdAt:h,note:n||void 0,ledgerEntryId:l},P=[...u,w],x=f>=s-250,E={partialPayments:P,paid:x,paymentDue:!x,updatedAt:new Date().toISOString(),expenseAdjustment:calculateExpenseAdjustment(s,P)};x?E.paidAmount=(0,a.AK)():E.paidAmount=f,await this.updateOrder(e,E)},async updatePartialPayment(e,t,i,l){let d=(0,n.z)();if(!d)throw Error("Firebase is not configured. Please set up your .env.local file with Firebase credentials.");let s=await this.getOrderById(e);if(!s)throw Error("Order not found");let u=s.partialPayments||[],c=u.findIndex(e=>e.id===t);if(-1===c)throw Error("Payment record not found");let m=u[c];m.amount;let y=Number(s.originalTotal||0),p=void 0!==i.amount?i.amount:m.amount,g=u.filter((e,t)=>t!==c).reduce((e,t)=>e+t.amount,0);if(g+p>y){let{formatIndianCurrency:e}=await r.e(766).then(r.bind(r,81766));throw Error(`Total payments cannot exceed original total of ${e(y)}`)}if(m.ledgerEntryId)try{let{ledgerService:e}=await r.e(512).then(r.bind(r,9909));await e.update(m.ledgerEntryId,{amount:p,date:i.date},{fromOrder:!0}),console.log("Γ\xa3\xe0 Synced payment update to ledger:",m.ledgerEntryId)}catch(e){console.error("Γ\xa5\xee Failed to sync payment update to ledger:",e)}let f={...m,amount:p,date:i.date||m.date,createdAt:m.createdAt||m.date,...l?{ledgerEntryId:l}:{}},h=[...u];h[c]=f;let w=h.reduce((e,t)=>e+t.amount,0),P=w>=y-250;try{let r=(0,a.JU)(d,o,e),n={paid:P,paymentDue:!P,updatedAt:new Date().toISOString(),partialPayments:h,expenseAdjustment:calculateExpenseAdjustment(y,h)};P?n.paidAmount=(0,a.AK)():n.paidAmount=w,await (0,a.r7)(r,n),console.log("Payment updated successfully:",t)}catch(e){if(console.error("Firestore error updating payment:",e),"permission-denied"===e.code)throw Error("Permission denied. Please check your Firestore security rules.");throw Error(`Failed to update payment: ${e.message||"Unknown error"}`)}},async removePartialPayment(e,t){let i=(0,n.z)();if(!i)throw Error("Firebase is not configured. Please set up your .env.local file with Firebase credentials.");let l=await this.getOrderById(e);if(!l)throw Error("Order not found");let d=l.partialPayments||[],s=d.find(e=>e.id===t);if(!s)throw Error("Payment record not found");if(s.ledgerEntryId)try{console.log("Removing linked ledger entry for payment:",s.ledgerEntryId);let{ledgerService:e}=await r.e(512).then(r.bind(r,9909));await e.remove(s.ledgerEntryId),console.log("Γ\xa3\xe0 Ledger entry removed, payment should be removed via hook");return}catch(e){console.error("Γ\xa5\xee Failed to remove linked ledger entry:",e)}let u=d.filter(e=>e.id!==t);try{let r=(0,a.JU)(i,o,e),n={updatedAt:new Date().toISOString(),expenseAdjustment:calculateExpenseAdjustment(Number(l.originalTotal||0),u)};u.length>0?n.partialPayments=u:n.partialPayments=(0,a.AK)();let d=Number(l.adjustmentAmount||0);n.adjustmentAmount=d+s.amount,await (0,a.r7)(r,n),console.log("Payment removed successfully:",t)}catch(e){if(console.error("Firestore error removing payment:",e),"permission-denied"===e.code)throw Error("Permission denied. Please check your Firestore security rules.");throw Error(`Failed to remove payment: ${e.message||"Unknown error"}`)}},async updatePaymentByLedgerEntryId(e,t){let r=(0,n.z)();if(!r)return;let i=await this.getAllOrders(),l=i.find(t=>(t.partialPayments||[]).some(t=>t.ledgerEntryId===e));if(!l||!l.id){console.log(`No order found for ledger entry update: ${e}`);return}let d=l.partialPayments||[],s=d.findIndex(t=>t.ledgerEntryId===e);if(-1===s)return;let u=d[s],c={...u,amount:void 0!==t.amount?t.amount:u.amount,date:t.date||u.date,createdAt:u.createdAt||u.date},m=[...d];m[s]=c;let y=Number(l.originalTotal||0),p=m.reduce((e,t)=>e+t.amount,0),g=p>=y-250,f={partialPayments:m,paid:g,paymentDue:!g,updatedAt:new Date().toISOString(),expenseAdjustment:calculateExpenseAdjustment(Number(l.originalTotal||0),m)},h=c.amount-u.amount;if(Math.abs(h)>.009){let e=Number(l.adjustmentAmount||0);f.adjustmentAmount=e-h}g?f.paidAmount=(0,a.AK)():f.paidAmount=p;try{let e=(0,a.JU)(r,o,l.id);await (0,a.r7)(e,f),console.log(`Γ\xa3\xe0 Synced ledger update to order ${l.id}`)}catch(e){console.error(`Failed to sync ledger update to order ${l.id}:`,e)}},async addCustomerPayment(e,t,r){let a=await this.getOrderById(e);if(!a)throw Error("Order not found");let n=Number(a.total||0),o=a.customerPayments||[],i=o.reduce((e,t)=>e+Number(t.amount||0),0);if(t<=0)throw Error("Payment amount must be greater than 0");let l=i+t;l>n&&console.warn(`Γ\xdc\xe1∩╕\xc5 Customer overpayment detected: ${l-n} over selling total. Total: ${l}, Selling: ${n}`);let d=new Date().toISOString(),s={id:Date.now().toString()+Math.random().toString(36).substr(2,9),amount:t,date:d,createdAt:d,note:r||void 0},u=[...o,s];await this.updateOrder(e,{customerPayments:u})},async updateCustomerPayment(e,t,i,l){let d=(0,n.z)();if(!d)throw Error("Firebase is not configured. Please set up your .env.local file with Firebase credentials.");let s=await this.getOrderById(e);if(!s)throw Error("Order not found");let u=s.customerPayments||[],c=u.findIndex(e=>e.id===t);if(-1===c)throw Error("Payment record not found");let m=u[c],y=m.amount,p=Number(s.total||0),g=void 0!==i.amount?i.amount:m.amount,f=u.filter((e,t)=>t!==c).reduce((e,t)=>e+t.amount,0);if(f+g>p){let{formatIndianCurrency:e}=await r.e(766).then(r.bind(r,81766));throw Error(`Total customer payments cannot exceed selling total of ${e(p)}`)}let h={...m,amount:g,date:i.date||m.date,createdAt:m.createdAt||m.date,...l?{ledgerEntryId:l}:{}},w=[...u];w[c]=h;try{let n=(0,a.JU)(d,o,e),i={updatedAt:new Date().toISOString(),customerPayments:w,revenueAdjustment:calculateRevenueAdjustment(p,w)};if(await (0,a.r7)(n,i),m.ledgerEntryId)try{let{ledgerService:e}=await r.e(512).then(r.bind(r,9909)),t=await e.getEntryById(m.ledgerEntryId);if(t){let r=Math.max(0,(t.amount||0)+(g-y));await e.update(m.ledgerEntryId,{amount:r},{fromOrder:!0})}}catch(e){console.error("❌ Failed to sync customer payment update to ledger:",e)}console.log("Customer payment updated successfully:",t)}catch(e){if(console.error("Firestore error updating customer payment:",e),"permission-denied"===e.code)throw Error("Permission denied. Please check your Firestore security rules.");throw Error(`Failed to update customer payment: ${e.message||"Unknown error"}`)}},async removeCustomerPayment(e,t){let i=(0,n.z)();if(!i)throw Error("Firebase is not configured. Please set up your .env.local file with Firebase credentials.");let l=await this.getOrderById(e);if(!l)throw Error("Order not found");let d=l.customerPayments||[],s=d.find(e=>e.id===t);if(!s)throw Error("Payment record not found");let u=d.filter(e=>e.id!==t);try{let n=(0,a.JU)(i,o,e),d={updatedAt:new Date().toISOString(),revenueAdjustment:calculateRevenueAdjustment(Number(l.total||0),u)};if(u.length>0?d.customerPayments=u:d.customerPayments=(0,a.AK)(),await (0,a.r7)(n,d),s.ledgerEntryId)try{let{ledgerService:e}=await r.e(512).then(r.bind(r,9909)),t=await e.getEntryById(s.ledgerEntryId);if(t){let r=Math.max(0,(t.amount||0)-s.amount);await e.update(s.ledgerEntryId,{amount:r},{fromOrder:!0})}}catch(e){console.error("❌ Failed to sync customer payment removal to ledger:",e)}console.log("Customer payment removed successfully:",t)}catch(e){if(console.error("Firestore error removing customer payment:",e),"permission-denied"===e.code)throw Error("Permission denied. Please check your Firestore security rules.");throw Error(`Failed to remove customer payment: ${e.message||"Unknown error"}`)}},async getUniquePartyNames(){let e=(0,n.z)();if(!e)return console.warn("Firebase is not configured. Returning empty array."),[];try{let t=(0,a.IO)((0,a.hJ)(e,o)),r=await (0,a.PL)(t),n=new Set;return r.forEach(e=>{let t=e.data();t.partyName&&"string"==typeof t.partyName&&n.add(t.partyName.trim())}),Array.from(n).sort()}catch(e){return console.error("Error fetching party names:",e),[]}},async getUniqueTruckOwners(){let e=(0,n.z)();if(!e)return console.warn("Firebase is not configured. Returning empty array."),[];try{let t=(0,a.IO)((0,a.hJ)(e,o)),r=await (0,a.PL)(t),n=new Set;return r.forEach(e=>{let t=e.data();t.truckOwner&&"string"==typeof t.truckOwner&&n.add(t.truckOwner.trim())}),Array.from(n).sort()}catch(e){return console.error("Error fetching truck owners:",e),[]}},async getUniqueTruckNumbers(){let e=(0,n.z)();if(!e)return console.warn("Firebase is not configured. Returning empty array."),[];try{let t=(0,a.IO)((0,a.hJ)(e,o)),r=await (0,a.PL)(t),n=new Set;return r.forEach(e=>{let t=e.data();t.truckNo&&"string"==typeof t.truckNo&&n.add(t.truckNo.trim())}),Array.from(n).sort()}catch(e){return console.error("Error fetching truck numbers:",e),[]}},async getUniqueSiteNames(){let e=(0,n.z)();if(!e)return console.warn("Firebase is not configured. Returning empty array."),[];try{let t=(0,a.IO)((0,a.hJ)(e,o)),r=await (0,a.PL)(t),n=new Set;return r.forEach(e=>{let t=e.data();t.siteName&&"string"==typeof t.siteName&&n.add(t.siteName.trim())}),Array.from(n).sort()}catch(e){return console.error("Error fetching site names:",e),[]}},async getUniqueSuppliers(){let e=(0,n.z)();if(!e)return console.warn("Firebase is not configured. Returning empty array."),[];try{let t=(0,a.IO)((0,a.hJ)(e,o)),r=await (0,a.PL)(t),n=new Set;return r.forEach(e=>{let t=e.data();t.supplier&&"string"==typeof t.supplier&&n.add(t.supplier.trim())}),Array.from(n).sort()}catch(e){return console.error("Error fetching suppliers:",e),[]}},async removePaymentsByLedgerEntryId(e){let t=(0,n.z)();if(!t){console.error("Firebase is not configured.");return}let r=await this.getAllOrders(),i=r.filter(t=>{let r=(t.partialPayments||[]).some(t=>t.ledgerEntryId===e),a=(t.customerPayments||[]).some(t=>t.ledgerEntryId===e);return r||a});for(let r of(console.log(`Found ${i.length} orders to cleanup for ledger entry ${e}`),i)){if(!r.id)continue;let n=(r.partialPayments||[]).filter(t=>t.ledgerEntryId!==e),i=(r.customerPayments||[]).filter(t=>t.ledgerEntryId!==e),l=(r.partialPayments?.length||0)!==n.length,d=(r.customerPayments?.length||0)!==i.length;if(!l&&!d)continue;let s=Number(r.originalTotal||0),u=n.reduce((e,t)=>e+t.amount,0),c=u>=s-250,m={updatedAt:new Date().toISOString()};if(l&&(m.partialPayments=n,m.paid=c,m.paymentDue=!c,m.expenseAdjustment=calculateExpenseAdjustment(s,n),c?m.paidAmount=(0,a.AK)():m.paidAmount=u),d){m.customerPayments=i;let e=Number(r.total||0);m.revenueAdjustment=calculateRevenueAdjustment(e,i)}try{let n=(0,a.JU)(t,o,r.id);await (0,a.r7)(n,m),console.log(`Γ\xa3\xe0 Removed payments for ledger ${e} from order ${r.id}`)}catch(e){console.error(`Failed to update order ${r.id} during ledger cleanup:`,e)}}},async reconcileSupplierOrders(e,t){let r=(0,n.z)();if(!r)return;let i=new Set(t);console.log(`≡ƒ\xf6\xe4 Reconciling orders for supplier: ${e}. Valid Ledger IDs: ${t.length}`);let l=(0,a.IO)((0,a.hJ)(r,o),(0,a.ar)("supplier","==",e)),d=await (0,a.PL)(l),s=[];d.forEach(e=>{s.push({id:e.id,...e.data()})});let u=0;for(let e of s){if(!e.id)continue;let t=e.partialPayments||[],n=t.filter(e=>!e.ledgerEntryId||i.has(e.ledgerEntryId));if(n.length!==t.length){u+=t.length-n.length;let i=Number(e.originalTotal||0),l=n.reduce((e,t)=>e+t.amount,0),d=l>=i-250,s={partialPayments:n,paid:d,paymentDue:!d,expenseAdjustment:calculateExpenseAdjustment(i,n),updatedAt:new Date().toISOString()};d?s.paidAmount=(0,a.AK)():s.paidAmount=l;try{await (0,a.r7)((0,a.JU)(r,o,e.id),s),console.log(`Γ\xa3\xe0 Removed orphan payments from order ${e.id}`)}catch(t){console.error(`Failed to update order ${e.id} during reconciliation:`,t)}}}console.log(`Γ\xa3\xe0 Reconciliation complete. Removed ${u} orphan payments.`)},async distributePaymentToSupplierOrders(e,t,r,i){let l=(0,n.z)();if(!l)return;console.log(`≡ƒ\xf6\xe4 Distributing payment of Γ\xe9╣${t} to supplier: ${e}`);let d=(0,a.IO)((0,a.hJ)(l,o),(0,a.ar)("supplier","==",e)),s=await (0,a.PL)(d),u=[];s.forEach(t=>{let r={id:t.id,...t.data()},a=!0===r.paid||!1===r.paymentDue;isExpensePaid(r)||a?console.log(`Skipping order ${r.id} for supplier ${e}: already marked paid.`):u.push(r)}),u.sort((e,t)=>new Date(e.date).getTime()-new Date(t.date).getTime()),console.log(`Found ${u.length} unpaid orders for supplier ${e}`);let c=t;for(let e of u){if(c<=0)break;if(!e.id)continue;let t=e.originalTotal||0,n=e.partialPayments||[],d=n.reduce((e,t)=>e+t.amount,0),s=Math.max(0,t-d),u=s<=250||!0===e.paid||!1===e.paymentDue;if(u){console.log(`Skipping auto-distribution to order ${e.id} (already within tolerance or marked paid).`);continue}let m=Math.max(0,s-250);if(m<=0)continue;let y=Math.min(c,m),p=new Date().toISOString(),g={id:Date.now().toString()+Math.random().toString(36).substr(2,9),amount:y,date:p,createdAt:p,ledgerEntryId:r,note:i||"Auto-distributed from ledger payment"},f=[...n,g],h=d+y,w=h>=t-250,P={partialPayments:f,paid:w,paymentDue:!w,expenseAdjustment:calculateExpenseAdjustment(t,f),updatedAt:new Date().toISOString()};w?P.paidAmount=(0,a.AK)():P.paidAmount=h,await (0,a.r7)((0,a.JU)(l,o,e.id),P),console.log(`Γ\xa3\xe0 Paid Γ\xe9╣${y} on order ${e.id} (Remaining: Γ\xe9╣${c-y})`),c-=y}c>0?console.log(`Γ\xdc\xe1∩╕\xc5 Payment distribution complete. Γ\xe9╣${c} remaining undistributed (no more unpaid orders).`):console.log("Γ\xa3\xe0 Payment fully distributed.")},async redistributeSupplierPayment(e,t){try{let{ledgerService:a}=await r.e(512).then(r.bind(r,9909));console.log(`≡ƒ\xf6\xe4 Redistributing ledger entry ${e} (date: ${t})`);let n=await a.getEntryById(e);if(!n){console.warn(`Γ\xa5\xee Ledger entry ${e} not found`);return}if("debit"!==n.type||!n.supplier){console.warn(`Γ\xa5\xee Ledger entry is not an expense with supplier (type: ${n.type}, supplier: ${n.supplier})`);return}console.log(`≡ƒ\xf4\xaa Getting orders for supplier: ${n.supplier}`);let o=await this.getAllOrders({supplier:n.supplier});console.log(`≡ƒ\xf4\xaa Found ${o.length} orders for supplier ${n.supplier}`);let l=0;o.forEach(t=>{let r=(t.partialPayments||[]).filter(t=>t.ledgerEntryId===e),a=r.reduce((e,t)=>e+Number(t.amount||0),0);l+=a}),console.log(`≡ƒ\xc6░ Total allocated to orders: ${l}, Ledger entry amount: ${n.amount}`);let d=n.supplier,s=o.map(t=>{let r=t.partialPayments||[],a=r.filter(t=>t.ledgerEntryId!==e),n=a.reduce((e,t)=>e+Number(t.amount||0),0),o=Number(t.originalTotal||0),l={...t,partialPayments:a},d=i(l);return{order:t,remaining:Math.max(0,o-n),currentPayments:r,tempOrder:l,isPaid:d}}).filter(({remaining:e,isPaid:t,order:r})=>{let a=!0===r.paid||!1===r.paymentDue,n=Math.max(0,e-250)>0&&!t&&!a;return n?console.log(`  ✅ Including order ${r.id} (${r.siteName||"N/A"}): remaining=${e}`):e<=250?console.log(`  ⏭️  Skipping order ${r.id} (${r.siteName||"N/A"}): no outstanding amount.`):(t||a)&&console.log(`  ⏭️  Skipping order ${r.id} (${r.siteName||"N/A"}): already marked paid.`),n}).sort((e,t)=>{let r=new Date(e.order.date).getTime(),a=new Date(t.order.date).getTime();if(r!==a)return r-a;let n=new Date(e.order.createdAt||e.order.updatedAt||e.order.date).getTime(),o=new Date(t.order.createdAt||t.order.updatedAt||t.order.date).getTime();return n-o});console.log(`Γ\xa3\xe0 Found ${s.length} orders with outstanding payments for redistribution`),0===s.length&&console.warn(`Γ\xdc\xe1∩╕\xc5 No orders with outstanding payments for supplier ${d}`);let u=[],c=0;o.forEach(t=>{if(!t.id)return;let r=(t.partialPayments||[]).filter(t=>t.ledgerEntryId===e);r.forEach(e=>{u.push({orderId:t.id,payment:e}),c+=Number(e.amount||0)})}),console.log(`≡ƒ\xc6╛ Preserving ${u.length} existing payment(s) totaling ${c}`);let m=n.amount;if((m=n.amount-c)<0){console.warn("Γ\xdc\xe1∩╕\xc5 New ledger amount is less than already distributed amount. Some payments should be reduced manually.");return}let y=[],p=new Map;for(let{order:r,remaining:a,currentPayments:n}of(u.forEach(({orderId:e,payment:t})=>{p.has(e)||p.set(e,[]),p.get(e).push(t)}),s)){if(m<=0)break;if(!r.id)continue;let o=p.get(r.id)||[],i=o.reduce((e,t)=>e+Number(t.amount||0),0);if(o.length>0){let t=n.filter(t=>t.ledgerEntryId!==e),a=[...t,...o];y.push({orderId:r.id,payment:a});continue}let l=Math.max(0,a-250),d=Math.max(0,l-i);if(d<=0){let t=n.filter(t=>t.ledgerEntryId!==e);t.length>0&&y.push({orderId:r.id,payment:t});continue}let s=Math.min(m,d),u=t;u&&!u.includes("T")&&(u=new Date(u+"T00:00:00").toISOString());let c={id:Date.now().toString()+Math.random().toString(36).substr(2,9),amount:s,date:u,note:"From ledger entry",ledgerEntryId:e},g=n.filter(t=>t.ledgerEntryId!==e),f=[...g,...o,c];y.push({orderId:r.id,payment:f}),m-=s,console.log(`  Γ\xa3\xf4 Adding payment of ${s} to order ${r.id}`)}for(let{orderId:t,payment:r}of(p.forEach((t,r)=>{if(!y.find(e=>e.orderId===r)){let a=o.find(e=>e.id===r);if(a){let n=a.partialPayments||[],o=n.filter(t=>t.ledgerEntryId!==e),i=[...o,...t];y.push({orderId:r,payment:i})}}}),console.log(`≡ƒ\xf4\xe8 Distribution summary: ${y.length} orders will be updated, ${m} remaining undistributed`),y))await this.updateOrder(t,{partialPayments:r}),console.log(`  Γ\xa3\xe0 Updated order ${t} with redistributed payment`);m>0?console.warn(`Γ\xdc\xe1∩╕\xc5 Could not fully redistribute. Remaining undistributed: ${m}`):console.log(`Γ\xa3\xe0 Successfully redistributed ledger entry ${e}`)}catch(e){throw console.error("Γ\xa5\xee Error redistributing ledger entry:",e),e}}}}};